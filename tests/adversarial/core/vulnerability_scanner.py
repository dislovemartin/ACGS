"""
Automated Vulnerability Scanner for ACGS-PGP

This module implements automated vulnerability scanning with CI/CD integration
and comprehensive security assessment capabilities.
"""

import asyncio
import logging
import time
import json
import subprocess
import os
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime, timezone
import aiohttp

from .adversarial_framework import (
    VulnerabilityResult, AttackCategory, VulnerabilitySeverity, AdversarialTestConfig
)

logger = logging.getLogger(__name__)


class AutomatedVulnerabilityScanner:
    """
    Automated vulnerability scanner with CI/CD integration.
    
    This scanner implements:
    - Static code analysis
    - Dynamic security testing
    - Dependency vulnerability scanning
    - Configuration security assessment
    """
    
    def __init__(self, config: AdversarialTestConfig):
        self.config = config
        self.scan_types = [
            "static_code_analysis",
            "dynamic_security_testing",
            "dependency_vulnerability_scan",
            "configuration_security_assessment",
            "container_security_scan",
            "network_security_scan",
            "api_security_scan",
            "authentication_security_scan"
        ]
        
        # Security scanning tools configuration
        self.scanning_tools = {
            "bandit": {
                "command": ["bandit", "-r", "src/", "-f", "json"],
                "description": "Python security linter"
            },
            "safety": {
                "command": ["safety", "check", "--json"],
                "description": "Python dependency vulnerability scanner"
            },
            "semgrep": {
                "command": ["semgrep", "--config=auto", "--json", "src/"],
                "description": "Static analysis security scanner"
            },
            "trivy": {
                "command": ["trivy", "fs", "--format", "json", "."],
                "description": "Container and filesystem vulnerability scanner"
            }
        }
    
    async def run_tests(
        self, 
        available_services: List[str], 
        service_endpoints: Dict[str, str]
    ) -> List[VulnerabilityResult]:
        """Run automated vulnerability scanning tests."""
        vulnerabilities = []
        
        # Run each scan type
        for scan_type in self.scan_types:
            logger.debug(f"Running automated vulnerability scan: {scan_type}")
            
            try:
                scan_results = await self._run_scan_type(
                    scan_type, available_services, service_endpoints
                )
                vulnerabilities.extend(scan_results)
                
            except Exception as e:
                logger.error(f"Error running {scan_type}: {e}")
        
        logger.info(f"Automated vulnerability scanning completed - {len(vulnerabilities)} vulnerabilities found")
        return vulnerabilities
    
    async def _run_scan_type(
        self,
        scan_type: str,
        available_services: List[str],
        service_endpoints: Dict[str, str]
    ) -> List[VulnerabilityResult]:
        """Run a specific type of vulnerability scan."""
        
        if scan_type == "static_code_analysis":
            return await self._run_static_code_analysis()
        elif scan_type == "dynamic_security_testing":
            return await self._run_dynamic_security_testing(available_services, service_endpoints)
        elif scan_type == "dependency_vulnerability_scan":
            return await self._run_dependency_vulnerability_scan()
        elif scan_type == "configuration_security_assessment":
            return await self._run_configuration_security_assessment()
        elif scan_type == "container_security_scan":
            return await self._run_container_security_scan()
        elif scan_type == "network_security_scan":
            return await self._run_network_security_scan(available_services, service_endpoints)
        elif scan_type == "api_security_scan":
            return await self._run_api_security_scan(available_services, service_endpoints)
        elif scan_type == "authentication_security_scan":
            return await self._run_authentication_security_scan(available_services, service_endpoints)
        else:
            return []
    
    async def _run_static_code_analysis(self) -> List[VulnerabilityResult]:
        """Run static code analysis security scanning."""
        vulnerabilities = []
        start_time = time.time()
        
        # Run Bandit security linter
        bandit_results = await self._run_security_tool("bandit")
        if bandit_results:
            vulnerabilities.extend(self._parse_bandit_results(bandit_results, start_time))
        
        # Run Semgrep static analysis
        semgrep_results = await self._run_security_tool("semgrep")
        if semgrep_results:
            vulnerabilities.extend(self._parse_semgrep_results(semgrep_results, start_time))
        
        return vulnerabilities
    
    async def _run_dependency_vulnerability_scan(self) -> List[VulnerabilityResult]:
        """Run dependency vulnerability scanning."""
        vulnerabilities = []
        start_time = time.time()
        
        # Run Safety dependency scanner
        safety_results = await self._run_security_tool("safety")
        if safety_results:
            vulnerabilities.extend(self._parse_safety_results(safety_results, start_time))
        
        # Run Trivy filesystem scanner
        trivy_results = await self._run_security_tool("trivy")
        if trivy_results:
            vulnerabilities.extend(self._parse_trivy_results(trivy_results, start_time))
        
        return vulnerabilities
    
    async def _run_security_tool(self, tool_name: str) -> Optional[Dict]:
        """Run a specific security scanning tool."""
        if tool_name not in self.scanning_tools:
            logger.warning(f"Security tool {tool_name} not configured")
            return None
        
        tool_config = self.scanning_tools[tool_name]
        
        try:
            # Run the security tool
            result = subprocess.run(
                tool_config["command"],
                capture_output=True,
                text=True,
                timeout=300  # 5 minute timeout
            )
            
            if result.returncode == 0 and result.stdout:
                return json.loads(result.stdout)
            else:
                logger.warning(f"Security tool {tool_name} failed: {result.stderr}")
                return None
                
        except subprocess.TimeoutExpired:
            logger.error(f"Security tool {tool_name} timed out")
            return None
        except json.JSONDecodeError:
            logger.error(f"Failed to parse {tool_name} output as JSON")
            return None
        except FileNotFoundError:
            logger.warning(f"Security tool {tool_name} not found - skipping")
            return None
        except Exception as e:
            logger.error(f"Error running security tool {tool_name}: {e}")
            return None
    
    def _parse_bandit_results(self, results: Dict, start_time: float) -> List[VulnerabilityResult]:
        """Parse Bandit security linter results."""
        vulnerabilities = []
        execution_time = (time.time() - start_time) * 1000
        
        for issue in results.get("results", []):
            severity = self._map_bandit_severity(issue.get("issue_severity", "LOW"))
            
            vulnerabilities.append(VulnerabilityResult(
                test_id=f"bandit_{issue.get('test_id', 'unknown')}_{len(vulnerabilities)}",
                attack_category=AttackCategory.CROSS_SERVICE_VULNERABILITY,
                severity=severity,
                service_target="static_analysis",
                vulnerability_description=f"Bandit security issue: {issue.get('issue_text', 'Unknown')}",
                attack_vector=f"Static code analysis detected: {issue.get('test_name', 'Unknown test')}",
                impact_assessment=f"Security vulnerability in {issue.get('filename', 'unknown file')}",
                proof_of_concept=json.dumps({
                    "filename": issue.get("filename"),
                    "line_number": issue.get("line_number"),
                    "code": issue.get("code")
                }),
                mitigation_recommendations=[
                    "Review and fix the identified security issue",
                    "Follow secure coding practices",
                    "Add security testing for this code path"
                ],
                cvss_score=self._calculate_bandit_cvss(severity),
                execution_time_ms=execution_time,
                timestamp=datetime.now(timezone.utc)
            ))
        
        return vulnerabilities
    
    def _parse_safety_results(self, results: Dict, start_time: float) -> List[VulnerabilityResult]:
        """Parse Safety dependency scanner results."""
        vulnerabilities = []
        execution_time = (time.time() - start_time) * 1000
        
        for vulnerability in results.get("vulnerabilities", []):
            vulnerabilities.append(VulnerabilityResult(
                test_id=f"safety_{vulnerability.get('id', 'unknown')}",
                attack_category=AttackCategory.CROSS_SERVICE_VULNERABILITY,
                severity=VulnerabilitySeverity.HIGH,
                service_target="dependencies",
                vulnerability_description=f"Dependency vulnerability: {vulnerability.get('advisory', 'Unknown')}",
                attack_vector=f"Vulnerable dependency: {vulnerability.get('package_name', 'unknown')}",
                impact_assessment=f"Security vulnerability in dependency {vulnerability.get('package_name')}",
                proof_of_concept=json.dumps({
                    "package": vulnerability.get("package_name"),
                    "version": vulnerability.get("analyzed_version"),
                    "vulnerability_id": vulnerability.get("id")
                }),
                mitigation_recommendations=[
                    f"Update {vulnerability.get('package_name')} to a secure version",
                    "Review dependency security regularly",
                    "Implement dependency scanning in CI/CD"
                ],
                cvss_score=7.5,
                execution_time_ms=execution_time,
                timestamp=datetime.now(timezone.utc)
            ))
        
        return vulnerabilities
    
    def _parse_semgrep_results(self, results: Dict, start_time: float) -> List[VulnerabilityResult]:
        """Parse Semgrep static analysis results."""
        vulnerabilities = []
        execution_time = (time.time() - start_time) * 1000
        
        for result in results.get("results", []):
            severity = self._map_semgrep_severity(result.get("extra", {}).get("severity", "INFO"))
            
            vulnerabilities.append(VulnerabilityResult(
                test_id=f"semgrep_{result.get('check_id', 'unknown')}_{len(vulnerabilities)}",
                attack_category=AttackCategory.CROSS_SERVICE_VULNERABILITY,
                severity=severity,
                service_target="static_analysis",
                vulnerability_description=f"Semgrep security issue: {result.get('message', 'Unknown')}",
                attack_vector=f"Static analysis pattern: {result.get('check_id', 'Unknown')}",
                impact_assessment=f"Security pattern detected in {result.get('path', 'unknown file')}",
                proof_of_concept=json.dumps({
                    "path": result.get("path"),
                    "start_line": result.get("start", {}).get("line"),
                    "end_line": result.get("end", {}).get("line")
                }),
                mitigation_recommendations=[
                    "Review and fix the identified security pattern",
                    "Implement secure coding practices",
                    "Add security code review process"
                ],
                cvss_score=self._calculate_semgrep_cvss(severity),
                execution_time_ms=execution_time,
                timestamp=datetime.now(timezone.utc)
            ))
        
        return vulnerabilities
    
    def _parse_trivy_results(self, results: Dict, start_time: float) -> List[VulnerabilityResult]:
        """Parse Trivy vulnerability scanner results."""
        vulnerabilities = []
        execution_time = (time.time() - start_time) * 1000
        
        for result in results.get("Results", []):
            for vulnerability in result.get("Vulnerabilities", []):
                severity = self._map_trivy_severity(vulnerability.get("Severity", "UNKNOWN"))
                
                vulnerabilities.append(VulnerabilityResult(
                    test_id=f"trivy_{vulnerability.get('VulnerabilityID', 'unknown')}",
                    attack_category=AttackCategory.CROSS_SERVICE_VULNERABILITY,
                    severity=severity,
                    service_target="filesystem",
                    vulnerability_description=f"Trivy vulnerability: {vulnerability.get('Title', 'Unknown')}",
                    attack_vector=f"Filesystem vulnerability: {vulnerability.get('VulnerabilityID', 'Unknown')}",
                    impact_assessment=f"Security vulnerability in {vulnerability.get('PkgName', 'unknown package')}",
                    proof_of_concept=json.dumps({
                        "package": vulnerability.get("PkgName"),
                        "version": vulnerability.get("InstalledVersion"),
                        "vulnerability_id": vulnerability.get("VulnerabilityID")
                    }),
                    mitigation_recommendations=[
                        f"Update {vulnerability.get('PkgName')} to version {vulnerability.get('FixedVersion', 'latest')}",
                        "Implement container security scanning",
                        "Regular security updates and patching"
                    ],
                    cvss_score=self._calculate_trivy_cvss(severity),
                    execution_time_ms=execution_time,
                    timestamp=datetime.now(timezone.utc)
                ))
        
        return vulnerabilities
    
    def _map_bandit_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map Bandit severity to VulnerabilitySeverity."""
        mapping = {
            "HIGH": VulnerabilitySeverity.HIGH,
            "MEDIUM": VulnerabilitySeverity.MEDIUM,
            "LOW": VulnerabilitySeverity.LOW
        }
        return mapping.get(severity.upper(), VulnerabilitySeverity.MEDIUM)
    
    def _map_semgrep_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map Semgrep severity to VulnerabilitySeverity."""
        mapping = {
            "ERROR": VulnerabilitySeverity.HIGH,
            "WARNING": VulnerabilitySeverity.MEDIUM,
            "INFO": VulnerabilitySeverity.LOW
        }
        return mapping.get(severity.upper(), VulnerabilitySeverity.MEDIUM)
    
    def _map_trivy_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map Trivy severity to VulnerabilitySeverity."""
        mapping = {
            "CRITICAL": VulnerabilitySeverity.CRITICAL,
            "HIGH": VulnerabilitySeverity.HIGH,
            "MEDIUM": VulnerabilitySeverity.MEDIUM,
            "LOW": VulnerabilitySeverity.LOW,
            "UNKNOWN": VulnerabilitySeverity.INFO
        }
        return mapping.get(severity.upper(), VulnerabilitySeverity.MEDIUM)
    
    def _calculate_bandit_cvss(self, severity: VulnerabilitySeverity) -> float:
        """Calculate CVSS score for Bandit findings."""
        score_map = {
            VulnerabilitySeverity.HIGH: 7.5,
            VulnerabilitySeverity.MEDIUM: 5.0,
            VulnerabilitySeverity.LOW: 3.0
        }
        return score_map.get(severity, 5.0)
    
    def _calculate_semgrep_cvss(self, severity: VulnerabilitySeverity) -> float:
        """Calculate CVSS score for Semgrep findings."""
        score_map = {
            VulnerabilitySeverity.HIGH: 8.0,
            VulnerabilitySeverity.MEDIUM: 6.0,
            VulnerabilitySeverity.LOW: 4.0
        }
        return score_map.get(severity, 6.0)
    
    def _calculate_trivy_cvss(self, severity: VulnerabilitySeverity) -> float:
        """Calculate CVSS score for Trivy findings."""
        score_map = {
            VulnerabilitySeverity.CRITICAL: 9.5,
            VulnerabilitySeverity.HIGH: 8.5,
            VulnerabilitySeverity.MEDIUM: 6.5,
            VulnerabilitySeverity.LOW: 4.0,
            VulnerabilitySeverity.INFO: 2.0
        }
        return score_map.get(severity, 6.0)
    
    async def _run_dynamic_security_testing(
        self, available_services: List[str], service_endpoints: Dict[str, str]
    ) -> List[VulnerabilityResult]:
        """Run dynamic security testing."""
        # Implementation for dynamic security testing
        return []
    
    async def _run_configuration_security_assessment(self) -> List[VulnerabilityResult]:
        """Run configuration security assessment."""
        # Implementation for configuration security assessment
        return []
    
    async def _run_container_security_scan(self) -> List[VulnerabilityResult]:
        """Run container security scanning."""
        # Implementation for container security scanning
        return []
    
    async def _run_network_security_scan(
        self, available_services: List[str], service_endpoints: Dict[str, str]
    ) -> List[VulnerabilityResult]:
        """Run network security scanning."""
        # Implementation for network security scanning
        return []
    
    async def _run_api_security_scan(
        self, available_services: List[str], service_endpoints: Dict[str, str]
    ) -> List[VulnerabilityResult]:
        """Run API security scanning."""
        # Implementation for API security scanning
        return []
    
    async def _run_authentication_security_scan(
        self, available_services: List[str], service_endpoints: Dict[str, str]
    ) -> List[VulnerabilityResult]:
        """Run authentication security scanning."""
        # Implementation for authentication security scanning
        return []
